cat: lonely: No such file or directory
$
?
1.txt
a
b
c
cat
d
file
file.txt
gen_tests.sh
magic
minitester.sh
out
out1
out2
out_bash
out_minishell
potato
README.md
res15
results
salut
test
test 1
test_list
tests_bonus.txt
tests.txt
veridict.sh
This is a error n test file. line1nline2 error nline3error
#!/usr/bin/env bash

create_tests()
{
n=1
i=0
while read line; do
if [[ ${#line} -gt 0 ]]; then
i=$((i+1))
local test='test'
test+="$n"
echo $line >> $test 2>&1;
mv $test $directory
n=$((n+1))

fi
done < $filename
}

# Creating the tests
filename='tests.txt'
directory='test_list'
mkdir $directory
chmod +rwx $directory;
create_tests;
exit;
#!/usr/bin/env bash

[ -e out_bash ] && rm -rf out_bash
[ -e out_minishell ] && rm -rf out_minishell
[ -e test_list ] && rm -rf test_list
mini="res"
prefix1="[?2004h"
prefix2="[?2004l"
i=0
n=1

clean_test()
{
dir=$1
mini=$2
touch "${dir}/${mini}"
while read -r line; do
if [[ "${line}" = "minishell:"* ]]; then
continue ;
else
echo "${line}" >> "${dir}/${mini}" 2>&1;
fi
done < $mini
}

do_tests()
{
test="test_list/test"
chmod +rwx "${test}${n}";
while [ -e "${test}${n}" ]; do
test="test_list/test"
local bash="res"
bash+="$n"
mini="res"
mini+="$n"
status=-1
bash < "${test}${n}" > $bash 2>&1
#if [ $(cat $bash | wc -c) -eq 0 ]; then
#	bash < "${test}${n}" > $bash 2>&1
orig="minishell\([0-9]*\)"
dest="minishell"
sed "s|${orig}|${dest}|g" "$bash" > new_bash
mv new_bash "$bash"
#fi
clean_test "out_bash" "$bash"
../minishell < "${test}${n}" > $mini 2>&1;
clean_test "out_minishell" "$mini"
i=$((i+1))
n=$((n+1))
[ -e "${mini}" ] && rm "${mini}"
[ -e "${test}${n}" ] && chmod +rwx "${test}${n}";
done
}

bash ./gen_tests.sh
mkdir out_minishell
mkdir out_bash
chmod +rwx out_bash;
chmod +rwx out_minishell;
do_tests;
bash ./veridict.sh
exit;
Test 1: [1;32m [OK][0m
1/1
Test 2: [1;32m [OK][0m
2/2
Test 3: [1;31m [KO][0m

_____________________________
[1;32mTest 3:[0m
"" | ""
[1;32mBash: [0m
[1;32mMini: [0m
mmiinniisshheelll:comml:canodmma '' notnd f 'o'u nndo
t found
_____________________________

2/3
Test 4: [1;32m [OK][0m
3/4
Test 5: [1;31m [KO][0m

_____________________________
[1;32mTest 5:[0m
(|)
[1;32mBash: [0m
[1;32mMini: [0m
mimniinsihsehlel:command 'l(l' not found
:command ')' not found
_____________________________

3/5
Test 6: [1;32m [OK][0m
4/6
Test 7: [1;32m [OK][0m
5/7
Test 8: [1;32m [OK][0m
6/8
Test 9: [1;32m [OK][0m
7/9
Test 10: [1;32m [OK][0m
8/10
Test 11: [1;32m [OK][0m
9/11
Test 12: [1;32m [OK][0m
10/12
Test 13: [1;32m [OK][0m
11/13
Test 14: [1;32m [OK][0m
12/14
Test 15: [1;32m [OK][0m
13/15
Test 16: [1;32m [OK][0m
14/16
Test 17: [1;32m [OK][0m
15/17
Test 18: [1;32m [OK][0m
16/18
Test 19: [1;32m [OK][0m
17/19
Test 20: [1;32m [OK][0m
18/20
Test 21: [1;32m [OK][0m
19/21
Test 22: [1;32m [OK][0m
20/22
Test 23: [1;32m [OK][0m
21/23
Test 24: [1;32m [OK][0m
22/24
Test 25: [1;32m [OK][0m
23/25
Test 26: [1;32m [OK][0m
24/26
Test 27: [1;31m [KO][0m

24/27
Test 28: [1;32m [OK][0m
25/28
Test 29: [1;32m [OK][0m
26/29
Test 30: [1;32m [OK][0m
27/30
Test 31: [1;31m [KO][0m

_____________________________
[1;32mTest 31:[0m
cat Makefile | grep pr | head -n 5 | cd file_not_exit
[1;32mBash: [0m
cat: Makefile: No such file or directory
[1;32mMini: [0m
or directory
_____________________________

27/31
Test 32: [1;31m [KO][0m

_____________________________
[1;32mTest 32:[0m
cat Makefile | grep pr | head -n 5 | hello
[1;32mBash: [0m
cat: Makefile: No such file or directory
[1;32mMini: [0m
Makefile: No such file or directory
_____________________________

27/32
Test 33: [1;32m [OK][0m
28/33
Test 34: [1;32m [OK][0m
29/34
Test 35: [1;32m [OK][0m
30/35
Test 36: [1;32m [OK][0m
31/36
Test 37: [1;32m [OK][0m
32/37
Test 38: [1;32m [OK][0m
33/38
Test 39: [1;32m [OK][0m
34/39
Test 40: [1;32m [OK][0m
35/40
Test 41: [1;32m [OK][0m
36/41
Test 42: [1;32m [OK][0m
37/42
Test 43: [1;32m [OK][0m
38/43
Test 44: [1;32m [OK][0m
39/44
Test 45: [1;32m [OK][0m
40/45
Test 46: [1;32m [OK][0m
41/46
Test 47: [1;32m [OK][0m
42/47
Test 48: [1;32m [OK][0m
43/48
Test 49: [1;32m [OK][0m
44/49
Test 50: [1;31m [KO][0m

_____________________________
[1;32mTest 50:[0m
clear < results
[1;32mBash: [0m
[1;32mMini: [0m
[H[2J[3Jminishell:exit
_____________________________

44/50
Test 51: [1;32m [OK][0m
45/51
Test 52: [1;32m [OK][0m
46/52
Test 53: [1;32m [OK][0m
47/53
Test 54: [1;32m [OK][0m
48/54
Test 55: [1;31m [KO][0m

_____________________________
[1;32mTest 55:[0m
echo $>?
[1;32mBash: [0m
[1;32mMini: [0m
a b c d
_____________________________

48/55
Test 56: [1;32m [OK][0m
49/56
Test 57: [1;32m [OK][0m
50/57
Test 58: [1;32m [OK][0m
51/58
Test 59: [1;32m [OK][0m
52/59
Test 60: [1;32m [OK][0m
53/60
Test 61: [1;32m [OK][0m
54/61
Test 62: [1;32m [OK][0m
55/62
Test 63: [1;32m [OK][0m
56/63
Test 64: [1;32m [OK][0m
57/64
Test 65: [1;32m [OK][0m
58/65
Test 66: [1;32m [OK][0m
59/66
Test 67: [1;32m [OK][0m
60/67
Test 68: [1;32m [OK][0m
61/68
Test 69: [1;32m [OK][0m
62/69
Test 70: [1;32m [OK][0m
63/70
Test 71: [1;32m [OK][0m
64/71
Test 72: [1;32m [OK][0m
65/72
Test 73: [1;32m [OK][0m
66/73
Test 74: [1;32m [OK][0m
67/74
Test 75: [1;32m [OK][0m
68/75
Test 76: [1;32m [OK][0m
69/76
Test 77: [1;32m [OK][0m
70/77
Test 78: [1;32m [OK][0m
71/78
Test 79: [1;32m [OK][0m
72/79
Test 80: [1;32m [OK][0m
73/80
Test 81: [1;32m [OK][0m
74/81
Test 82: [1;32m [OK][0m
75/82
Test 83: [1;32m [OK][0m
76/83
Test 84: [1;32m [OK][0m
77/84
Test 85: [1;32m [OK][0m
78/85
Test 86: [1;32m [OK][0m
79/86
Test 87: [1;32m [OK][0m
80/87
Test 88: [1;32m [OK][0m
81/88
Test 89: [1;32m [OK][0m
82/89
Test 90: [1;32m [OK][0m
83/90
Test 91: [1;32m [OK][0m
84/91
Test 92: [1;32m [OK][0m
85/92
Test 93: [1;32m [OK][0m
86/93
Test 94: [1;31m [KO][0m

_____________________________
[1;32mTest 94:[0m
echo -n -nn -nnm teste
[1;32mBash: [0m
[1;32mMini: [0m
-nnm testeminishell:exit_____________________________

86/94
Test 95: [1;31m [KO][0m

_____________________________
[1;32mTest 95:[0m
echo -nnnn teste
[1;32mBash: [0m
[1;32mMini: [0m
teste_____________________________

86/95
Test 96: [1;31m [KO][0m

_____________________________
[1;32mTest 96:[0m
echo -nnn "" | wc -l | grep 0 | wc -l
[1;32mBash: [0m
1
[1;32mMini: [0m
0
_____________________________

86/96
Test 97: [1;31m [KO][0m

_____________________________
[1;32mTest 97:[0m
echo -n -nteste
[1;32mBash: [0m
[1;32mMini: [0m
-ntesteminishell:exit
_____________________________

86/97
Test 98: [1;32m [OK][0m
87/98
Test 99: [1;32m [OK][0m
88/99
Test 100: [1;32m [OK][0m
89/100
Test 101: [1;32m [OK][0m
90/101
Test 102: [1;32m [OK][0m
91/102
Test 103: [1;32m [OK][0m
92/103
Test 104: [1;32m [OK][0m
93/104
Test 105: [1;32m [OK][0m
94/105
Test 106: [1;32m [OK][0m
95/106
Test 107: [1;32m [OK][0m
96/107
Test 108: [1;32m [OK][0m
97/108
Test 109: [1;32m [OK][0m
98/109
Test 110: [1;32m [OK][0m
99/110
Test 111: [1;31m [KO][0m

99/111
Test 112: [1;32m [OK][0m
100/112
Test 113: [1;31m [KO][0m

100/113
Test 114: [1;32m [OK][0m
101/114
Test 115: [1;32m [OK][0m
102/115
Test 116: [1;31m [KO][0m

_____________________________
[1;32mTest 116:[0m
exit 1 exit
[1;32mBash: [0m
[1;32mMini: [0m
exit
_____________________________

102/116
Test 117: [1;32m [OK][0m
103/117
Test 118: [1;32m [OK][0m
104/118
Test 119: [1;31m [KO][0m

_____________________________
[1;32mTest 119:[0m
exit << magic
[1;32mBash: [0m
[1;32mMini: [0m
exit
_____________________________

104/119
Test 120: [1;31m [KO][0m

104/120
Test 121: [1;32m [OK][0m
105/121
Test 122: [1;31m [KO][0m

105/122
Test 123: [1;32m [OK][0m
106/123
Test 124: [1;32m [OK][0m
107/124
Test 125: [1;32m [OK][0m
108/125
Test 126: [1;32m [OK][0m
109/126
Test 127: [1;32m [OK][0m
110/127
Test 128: [1;32m [OK][0m
111/128
Test 129: [1;32m [OK][0m
112/129
Test 130: [1;32m [OK][0m
113/130
Test 131: [1;32m [OK][0m
114/131
Test 132: [1;32m [OK][0m
115/132
Test 133: [1;32m [OK][0m
116/133
Test 134: [1;32m [OK][0m
117/134
Test 135: [1;32m [OK][0m
118/135
Test 136: [1;32m [OK][0m
119/136
Test 137: [1;31m [KO][0m

119/137
Test 138: [1;32m [OK][0m
120/138
Test 139: [1;32m [OK][0m
121/139
Test 140: [1;32m [OK][0m
122/140
Test 141: [1;32m [OK][0m
123/141
Test 142: [1;32m [OK][0m
124/142
Test 143: [1;31m [KO][0m

_____________________________
[1;32mTest 143:[0m
find /path/to/directory -type f -size +100M -printf '%f %sn' | exit
[1;32mBash: [0m
find: â€˜/path/to/directoryâ€™: No such file or directory
[1;32mMini: [0m
exit
find: â€˜/path/to/directoryâ€™: No such file or directory
_____________________________

124/143
Test 144: [1;31m [KO][0m

_____________________________
[1;32mTest 144:[0m
find . -type f | wc -l
[1;32mBash: [0m
487
[1;32mMini: [0m
488
_____________________________

124/144
Test 145: [1;32m [OK][0m
125/145
Test 146: [1;31m [KO][0m

_____________________________
[1;32mTest 146:[0m
ls | exit
[1;32mBash: [0m
[1;32mMini: [0m
exit
_____________________________

125/146
Test 147: [1;32m [OK][0m
126/147
Test 148: [1;31m [KO][0m

_____________________________
[1;32mTest 148:[0m
'ls | 'wc' '|' >> 1.txt'
[1;32mBash: [0m
[1;32mMini: [0m
:command ' >> 1.txt' not found
_____________________________

126/148
Test 149: [1;32m [OK][0m
127/149
Test 150: [1;32m [OK][0m
128/150
Test 151: [1;31m [KO][0m

_____________________________
[1;32mTest 151:[0m
<< magic wc
[1;32mBash: [0m
0 0 0
[1;32mMini: [0m
0 0 0
_____________________________

128/151
Test 152: [1;32m [OK][0m
129/152
Test 153: [1;32m [OK][0m
130/153
Test 154: [1;32m [OK][0m
131/154
Test 155: [1;32m [OK][0m
132/155
Test 156: [1;32m [OK][0m
133/156
Test 157: [1;32m [OK][0m
134/157
Test 158: [1;32m [OK][0m
135/158
Test 159: [1;32m [OK][0m
136/159
Test 160: [1;32m [OK][0m
137/160
Test 161: [1;32m [OK][0m
138/161
Test 162: [1;32m [OK][0m
139/162
Test 163: [1;32m [OK][0m
140/163
Test 164: [1;32m [OK][0m
141/164
Test 165: [1;32m [OK][0m
142/165
Test 166: [1;32m [OK][0m
143/166
Test 167: [1;32m [OK][0m
144/167
Test 168: [1;32m [OK][0m
145/168
Test 169: [1;32m [OK][0m
146/169
Test 170: [1;32m [OK][0m
147/170
Test 171: [1;32m [OK][0m
148/171
Test 172: [1;32m [OK][0m
149/172
Test 173: [1;32m [OK][0m
150/173
Test 174: [1;32m [OK][0m
151/174
Test 175: [1;32m [OK][0m
152/175
2
cat: out_bash: Is a directory
cat: out_minishell: Is a directory
# minitester
Output tester for the 42 Common Core 'minishell' project | Made to help during the development stages | On going

Prerequisites:
- Have 'expect' installed in your linux distribution. If not, run:
sudo apt install expect
- Your shell executable must have functional prompt capturing and processing capabilities
- Your shell must be named 'minishell' and have a readline prompt containing the sequence '$ ' (dollar sign + space)
- Your executable must be compiled without -fsanitize statements, as it would alter 'minitesters' results


Instructions:
- Place the 'minitester' folder next to your minishell executable
- Enter the 'minitester' folder and run:
bash ./minitester.sh


Evaluating the results:
- Check individual tests by comparing the output of the files within the 'out_bash' and 'out_minishell' folders.
For this, look for matching filenames in both folders in the format 'res + test number'
- Check the content of the performed test in the 'test_list' folder (test + test number + .sh)
- At the time of writing, this program has not been tested against final minishell projects.
Please, see this program as an auxiliar program and not as a means of final testing.


Further usage:
- You can add more tests by adding new lines to the "tests.txt" file within the 'minitester' folder.
Please add them before the last line of the file (containing the 'exit\' sequence)
- New tests function properly in one-line format. At the time of writing multiline test format has not been addressed


Final considerations:
- In cases where results involve stderr messages, preference was given to expect's messaging system over bash's.
This was done, both due to expect's constraints, and to allow results to match up in diff statements whenever standard errors are involved.
This also means that you won't be able to compare your shell's own messaging system against the original bash when running 'minitester'.
- A validation was added to avoid failing scores in tests containing the character ';'.
This was done to avoid mismatching results, as the project guides state that this character is not to be interpreted by your minishell.
If needed, the same can be removed by deleting the 'elif' condition and corresponding statements in 'veridict.sh'.

Thanks!
cat: res27: input file is output file
[H[2J[3Jbonjour
cat: test_list: Is a directory
"  "
""
"" | ""
''
(|)
..
|
$? * $?
$LESS$VAR
$SHLVL
'$TERM'
$TERM
$test
$test | $test
$test && echo $?
$test || echo $?
>a ls >b >>c >d
>a ls <machin >>c >d
/bin/echo bonjour
/bin/ls
/bin/ls && echo $?
/bin/ls || echo $?
/bin/ls este_ficheir_nao_existe && echo $?
/bin/ls este_ficheir_nao_existe || echo $?
/bin/pwd
>|cat
cat bla
(cat echo 5)
cat echo 5
cat file.txt | grep 'error' | wc -l
cat file.txt | tr -s ' ' '\n' | sort | uniq -c | sort -nr
cat file.txt | tr -s ' ' '\n' | sort | uniq -c | sort -nr | awk '{print $2 $1}'
cat *.h | grep struct > structs_file && echo "_STRUCT LIST:" >> structs_file && sort structs_file > sorted_structs && cat sorted_structs && rm *structs*
(cat lonely)
cat lonely
cat lonely $test*
cat lonely | clear | echo 5
cat lonely || echo $?
((cat lonely || echo $? > erro) | ls) && cat erro
cat lonely && echo $? | > test
cat lonely | (echo 5)
cat lonely|(ls)
cat lonely | ls && cat lonely | ls
cat magic
cat << magic > magic
cat Makefile | grep pr | head -n 5 | cd file_not_exit
cat Makefile | grep pr | head -n 5 | hello
cat *test
cat < test
cat test
cat test**
cat test$*
"cd .."
'cd ..'
cd ""
cd ../../../../../..
CD .
CD ..
cd $HOME/Bureau
cd $vari
cd $vari ""
cd /home/..
cd /home/dir
cd /home/user42/
cd ./path_not_found
cd ~ && pwd
cd . && pwd && cd .. && pwd && pwd && cd /bin/ls && pwd
cd random_cmd && echo $?
cd random_cmd ; echo $?
cd too many arguments
(clear)
clear | $test
clear < results
clear > results
diff test test2
echo
echo $*
echo $>?
echo $? % $?
echo $? + $?
echo $OLDPWD && cd $OLDPWD && echo $OLDPWD && cd $OLDPWD && echo $OLDPWD
echo $PATH | wc -l | grep 1 | echo $? | grep 0
echo $PWD >> test1 >> test2 > test1
(echo $test) && echo $? > test3
echo "$tests" "Makefile"
echo "$tests""Makefile"
echo "$tests"Makefile
echo $USER
echo $USER$var\$USER$USER\$USERtest$USER
echo '$USER' echo $USER
echo $var bonjour
echo "12\""
echo 2 > out1 >> out2
echo 2 >> out1 > out2
(echo 5)
echo 5
(echo 5 cat)
echo 5 cat
echo 5 | (cat)
echo\ a
echo "'abc'"
echo '"abc"'
echo "agora 'mais' fdd"
echo a"hey | ls
echo a"hey" | ls
echo a"hey"|ls
echo a"hey|ls
echo "bip | bip ><"
echo "" bonjour
echo bonjour > $test
echo bonjour && ls
echo bonjour \; ls
echo bonjour > "test 1"
echo "cat lol.c | cat > lol.c"
echo "''" | grep ""
echo "Hello && World!"
echo "Hello | World!"
echo "Hello || World!"
echo "Hello && world!" > output.txt && cat output.txt && echo "Hello world!" >> output.txt && cat output.txt
echo "Hello | world!" > output.txt && cat output.txt && echo "Hello world!" >> output.txt && cat output.txt
echo "Hello || world!" > output.txt && cat output.txt && echo "Hello world!" >> output.txt && cat output.txt
echo "hey" | ls
echo "hey" | ls
echo "hey"|ls
echo "hey|ls
echo -n
echo -n ""
(((echo -n 4) && echo 2))
((echo -n 4) && echo 2)
echo -nnm teste
echo -nnm "" | wc -l | grep 1
echo -n -nn -nnm teste
echo -nnnn teste
echo -nnn "" | wc -l | grep 0 | wc -l
echo -n -nteste
echo -n 'serÃ¡"que vai dar'parsing"
echo -n "" | wc -l | grep 0 | wc -l
echo "" -n | wc -l | grep 1
echo "pedro pinto"
echo "\s" && echo "\\s"
echo "\s" ; echo "\\s"
echo test|
echo test|>
echo test|>cat
echo test|cat
echo test|cat>
echo teste
echo test > file test1
echo "This is a error \n test file. line1\nline2 error \nline3error" > file.txt
echo "" | wc -l | grep 1
env
env ""
env $vari
env > test
env > test2
exit 1 exit
exit 300 || echo $?
exit | echo $? > test
exit exit 1
exit << magic
export
export ""
export ($test)
(export $test) && export
(export $test) && export > test1 && unset test && export > test2 && diff test1 test2
export $test && export > test1 && unset test && export > test2 && diff test1 test2
export $var
export $var=test
export $var=test && export $var
export $var=test ; export $var
export 3A && echo $? && unset 3A && echo $?
export 3A && echo $? || unset 3A && echo $?
export 3A || echo $? && unset 3A || echo $?
export 3A || echo $? || unset 3A || echo $?
export "" . : , ! \\ + = - _ _a
export  a127  a=
export  a127  a= " "
export A2=34 A2=42 && export && export | wc -l && env | wc -l && echo $A2 && unset A2
export A2=34 && export && export | wc -l && env | wc -l && echo $A2 && unset A2
export A2=42 && export && export | wc -l && env | wc -l && echo $A2 && unset A2
export a=a b=b c=c d=d e=e && echo "$a "$b" $c $d" "$e" && unset a b c d e
export ...cookie? $OLDPWD
export cookie OLDPWD
(export (echo -n $test))
export env
export | grep cookie > test
export | grep OLDPWD >> test
export HOME= && cd
export HOME= ; cd
export loop='bonjour$loop' && echo $loop
export loop='bonjour$loop' ; echo $loop
export Nao_Existe && echo $?
export Nao_Existe || echo $?
export test=123\" && echo $test
export test=123\" ; echo $test
export test=123\\ && echo $test
export test=123\\ ; echo $test
export test=123\' && echo $test && echo $test
export test=123\' ; echo $test ; echo $test
export test1="export test2=test3" && $test1 && echo $test2
export "" test=a
export test=a && echo $test
export test=a ; echo $test
export test="env | grep OLDPWD" && $test
export test="exit" && ($test) && echo $?
(export test="exit 1123a" && ($test)) || echo $?
(export test="exit 1224" && ($test)) || echo $?
(export test="exit 1224a" && ($test)) || echo $?
export test="  foo    bar  " && echo $test
export test="  foo    bar  " ; echo $test
export test=" foo   bar " && echo """$test"""
export test=" foo   bar " && echo ""$test""
export test=" foo   bar " && echo "$test"
export test=" foo   bar " ; echo """$test"""
export test=" foo   bar " ; echo ""$test""
export test=" foo   bar " ; echo "$test"
export test="  foo    bar  " && echo "ab"$test
export test="  foo    bar  " && echo ab$test
export test="  foo    bar  " ; echo "ab"$test
export test="  foo    bar  " ; echo ab$test
export test=" foo   bar " && echo ab"$test" | cat -e
export test=" foo   bar " ; echo ab"$test" | cat -e
export "test=ici"=coucou && echo $test
export "test=ici"=coucou ; echo $test
export ""  && unset ""
export var=a && export $var=test && echo $var $a
export var=a ; export $var=test ; echo $var $a
export var=at && c$var Makefile
export var=at ; c$var Makefile
export var="cat Makefile | grep >" && echo $var
export var="cat Makefile | grep >" ; echo $var
export var entÃ£o export var = teste
export var= s\ -la && l$var
export var= s\ -la ; l$var
export VAR="This is a test variable." && echo $VAR && unset VAR && echo $VAR && cat output.txt
export var="  truc"&& echo $var
export var="  truc"; echo $var
export var="truc  "&& echo $var | cat -e
export var="truc  "; echo $var | cat -e
>file
file_name
./file_that_is_not_an_executable
find . -name "*.txt" -exec cat {} + | wc -l
find /path/to/directory -type f -size +100M -printf '%f %s\n' | exit
find . -type f | wc -l
ls *
ls bonjour && echo $?
ls bonjour ; echo $?
(ls)|cat
(ls|)cat
ls(|)cat
ls | exit
ls -l < input.txt > output.txt && cat output.txt
ls | sort
'ls | 'wc' '|' >> 1.txt'
'ls | wc | >> 1.txt'
ls | wc | >> 1.txt
<< magic wc
./minishell < exit 122 > lixo && echo $?
./minishell < exit 122 > lixo || echo $?
./minishell < exit 122 > lixo && echo $?
./minishell < exit 122 > || echo $?
./minishell < exit 50 > && echo $?
./minishell < exit 50 > || echo $?
./minishell < exit 50 > && echo $?
./minishell < exit 50 > || echo $?
./minishell < exit && > echo $?
./minishell < exit || > echo $?
./minishell < exit && > echo $?
./minishell < exit || > echo $?
./minishell	< ./minishell < exit 300 && echo $?
not_cmd
not_cmd bonjour > salut
< potato cd $PWD
ps aux --sort=-%mem | head -n 10
pwd && cd . && (pwd && cd .. && pwd) && pwd && cd $OLDPWD && pwd && cd $PWD
(pwd && cd .. && pwd) && pwd && cd .
/sbin/env
/snap/bin/no_command
sort < output.txt && cat output.txt
sort -r << test > potato
sort t* > test
TERM
test|
>test|cat
test|cat
test|cat>
> test | echo blabla
> test | echo blabla; rm test
(unset $HOME) && env
unset "" . : , ! \\ + = - _ _a
unset a*
unset  ...cookie? ""
unset HOME
unset / -n
unset PATH && env && echo $? && export PATH="/usr/local/bin:/usr/bin:/bin:/usr/local/sbin:/usr/sbin:/sbin" && env && echo $?
unset PATH ; ls
unset PWD
unset TERM && env && export TERM=new_term_42
unset "" test
unset test && $test
unset test && (export test="" && export > test1) && export $test > test2 && diff test1 test2
unset test && export test="" && export > test1 && export $test > test2 && diff test1 test2
unset var
/usr/local/bin/pwd
/usr/share/echo -n pinto
"  "
""
"" | ""
''
(|)
..
|
$? * $?
$LESS$VAR
$SHLVL
'$TERM'
$TERM
$test
$test | $test
>a ls >b >>c >d
>a ls <machin >>c >d
/bin/echo bonjour
/bin/ls
/bin/pwd
>|cat
cat bla
cat echo 5
cat file.txt | grep 'error' | wc -l
cat file.txt | tr -s ' ' '\n' | sort | uniq -c | sort -nr
cat file.txt | tr -s ' ' '\n' | sort | uniq -c | sort -nr | awk '{print $2 $1}'
cat lonely
cat lonely $test*
cat lonely | clear | echo 5
cat magic
cat << magic > magic
cat Makefile | grep pr | head -n 5 | cd file_not_exit
cat Makefile | grep pr | head -n 5 | hello
cat < test
cat test
"cd .."
'cd ..'
cd ""
cd ../../../../../..
CD .
CD ..
cd $HOME/Bureau
cd $vari
cd $vari ""
cd /home/..
cd /home/dir
cd /home/user42/
cd ./path_not_found
cd too many arguments
clear | $test
clear < results
clear > results
diff test test2
echo
echo $*
echo $>?
echo $? % $?
echo $? + $?
echo $PATH | wc -l | grep 1 | echo $? | grep 0
echo $PWD >> test1 >> test2 > test1
echo "$tests" "Makefile"
echo "$tests""Makefile"
echo "$tests"Makefile
echo $USER
echo $USER$var\$USER$USER\$USERtest$USER
echo '$USER' echo $USER
echo $var bonjour
echo "12\""
echo 2 > out1 >> out2
echo 2 >> out1 > out2
echo 5
echo 5 cat
echo\ a
echo "'abc'"
echo '"abc"'
echo "agora 'mais' fdd"
echo a"hey | ls
echo a"hey" | ls
echo a"hey"|ls
echo a"hey|ls
echo "bip | bip ><"
echo "" bonjour
echo bonjour > $test
echo bonjour > "test 1"
echo "cat lol.c | cat > lol.c"
echo "''" | grep ""
echo "Hello | World!"
echo "hey" | ls
echo "hey"|ls
echo "hey|ls
echo -n
echo -n ""
echo -nnm teste
echo -nnm "" | wc -l | grep 1
echo -n -nn -nnm teste
echo -nnnn teste
echo -nnn "" | wc -l | grep 0 | wc -l
echo -n -nteste
echo -n 'serÃ¡"que vai dar'parsing"
echo -n "" | wc -l | grep 0 | wc -l
echo "" -n | wc -l | grep 1
echo "pedro pinto"
echo test|
echo test|>
echo test|>cat
echo test|cat
echo test|cat>
echo teste
echo test > file test1
echo "This is a error \n test file. line1\nline2 error \nline3error" > file.txt
echo "" | wc -l | grep 1
env
env ""
env $vari
env > test
env > test2
exit 1 exit
exit | echo $? > test
exit exit 1
exit << magic
export
export ""
export $var
export $var=test
export "" . : , ! \\ + = - _ _a
export  a127  a=
export  a127  a= " "
export a=a b=b c=c d=d e=e
echo "$a "$b" $c $d" "$e"
unset a b c d e
export ...cookie? $OLDPWD
export cookie OLDPWD
export env
export | grep cookie > test
export | grep OLDPWD >> test
export "" test=a
export ""  && unset ""
export var=a && export $var=test && echo $var $a
export var entÃ£o export var = teste
>file
file_name
./file_that_is_not_an_executable
find . -name "*.txt" -exec cat {} + | wc -l
find /path/to/directory -type f -size +100M -printf '%f %s\n' | exit
find . -type f | wc -l
ls *
ls | exit
ls | sort
'ls | 'wc' '|' >> 1.txt'
'ls | wc | >> 1.txt'
ls | wc | >> 1.txt
<< magic wc
not_cmd
not_cmd bonjour > salut
< potato cd $PWD
ps aux --sort=-%mem | head -n 10
/sbin/env
/snap/bin/no_command
sort -r << test > potato
sort t* > test
TERM
test|
>test|cat
test|cat
test|cat>
> test | echo blabla
unset "" . : , ! \\ + = - _ _a
unset a*
unset  ...cookie? ""
unset HOME
unset / -n
unset PWD
unset "" test
unset var
/usr/local/bin/pwd
/usr/share/echo -n pinto
#!/usr/bin/env bash

# ANSI color escape sequences
RED='\033[1;31m'
GREEN='\033[1;32m'
WHITE='\033[1;37m'
BLUE='\033[1;34m'
CYAN='\033[1;36m'
UNDERLINE='\033[4m'
RESET='\033[0m'

#Gathering needed variables
filename='res.txt'
directory='out_minishell'
prefix1="[?2004h"
prefix2="[?2004l"

# Reading results
readfile()
{
read="$1"

while read line; do
echo $line
done < ${read}
}

# Comparing results
veridict()
{
count=0
n=1
while read line; do
if [[ "${#line}" > 0 ]]; then
local res="res"
res+="$n"
if diff -q out_bash/${res} ${directory}/${res} > /dev/null 2>&1; then
echo -ne "Test ${n}: ${GREEN} [OK]${RESET}"
echo ""
count=$((count+1))
elif [[ "${line}" = *";"* ]]; then
echo -ne "Test ${n}: ${GREEN} [OK]${RESET}"
echo ""
else
echo -e "Test ${n}: ${RED} [KO]${RESET}"
echo ""
if [[ $(cat "test_list/test${n}") != *"env"* && $(cat "test_list/test${n}") != *"export"* && $line != *"*"* ]]; then
echo "_____________________________"
echo -e "${GREEN}Test ${n}:${RESET}"
echo $(cat test_list/test${n})
echo -e "${GREEN}Bash: ${RESET}"
readfile "out_bash/res${n}"
echo -e "${GREEN}Mini: ${RESET}"
readfile "out_minishell/res${n}"
echo "_____________________________"
echo ""
fi
fi
echo "${count}/${n}"
n=$((n+1))
fi
done < tests.txt
}

# Getting the results!
chmod +rwx $directory;
chmod +rwx out_bash;
veridict;
exit;
