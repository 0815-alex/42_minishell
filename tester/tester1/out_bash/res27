cat: lonely: No such file or directory
$
?
1.txt
a
b
c
cat
d
file
file.txt
gen_tests.sh
magic
minitester.sh
out1
out2
out_bash
out_minishell
potato
README.md
res15
results
salut
test
test 1
test_list
tests_bonus.txt
tests.txt
veridict.sh
This is a error n test file. line1nline2 error nline3error
#!/usr/bin/env bash

create_tests()
{
n=1
i=0
while read line; do
if [[ ${#line} -gt 0 ]]; then
i=$((i+1))
local test='test'
test+="$n"
echo $line >> $test 2>&1;
mv $test $directory
n=$((n+1))

fi
done < $filename
}

# Creating the tests
filename='tests.txt'
directory='test_list'
mkdir $directory
chmod +rwx $directory;
create_tests;
exit;
#!/usr/bin/env bash

[ -e out_bash ] && rm -rf out_bash
[ -e out_minishell ] && rm -rf out_minishell
[ -e test_list ] && rm -rf test_list
mini="res"
prefix1="[?2004h"
prefix2="[?2004l"
i=0
n=1

clean_test()
{
dir=$1
mini=$2
touch "${dir}/${mini}"
while read -r line; do
if [[ "${line}" = "minishell"* ]]; then
continue ;
else
echo "${line}" >> "${dir}/${mini}" 2>&1;
fi
done < $mini
}

do_tests()
{
test="test_list/test"
chmod +rwx "${test}${n}";
while [ -e "${test}${n}" ]; do
test="test_list/test"
local bash="res"
bash+="$n"
mini="res"
mini+="$n"
status=-1
bash < "${test}${n}" > $bash 2>&1
#if [ $(cat $bash | wc -c) -eq 0 ]; then
#	bash < "${test}${n}" > $bash 2>&1
orig="minishell\([0-9]*\)"
dest="minishell"
sed "s|${orig}|${dest}|g" "$bash" > new_bash
mv new_bash "$bash"
#fi
clean_test "out_bash" "$bash"
../minishell < "${test}${n}" > $mini 2>&1;
clean_test "out_minishell" "$mini"
i=$((i+1))
n=$((n+1))
[ -e "${mini}" ] && rm "${mini}"
[ -e "${test}${n}" ] && chmod +rwx "${test}${n}";
done
}

bash ./gen_tests.sh
mkdir out_minishell
mkdir out_bash
chmod +rwx out_bash;
chmod +rwx out_minishell;
do_tests;
bash ./veridict.sh
exit;
2
cat: out_bash: Is a directory
cat: out_minishell: Is a directory
# minitester
Output tester for the 42 Common Core 'minishell' project | Made to help during the development stages | On going

Prerequisites:
- Have 'expect' installed in your linux distribution. If not, run:
sudo apt install expect
- Your shell executable must have functional prompt capturing and processing capabilities
- Your shell must be named 'minishell' and have a readline prompt containing the sequence '$ ' (dollar sign + space)
- Your executable must be compiled without -fsanitize statements, as it would alter 'minitesters' results


Instructions:
- Place the 'minitester' folder next to your minishell executable
- Enter the 'minitester' folder and run:
bash ./minitester.sh


Evaluating the results:
- Check individual tests by comparing the output of the files within the 'out_bash' and 'out_minishell' folders.
For this, look for matching filenames in both folders in the format 'res + test number'
- Check the content of the performed test in the 'test_list' folder (test + test number + .sh)
- At the time of writing, this program has not been tested against final minishell projects.
Please, see this program as an auxiliar program and not as a means of final testing.


Further usage:
- You can add more tests by adding new lines to the "tests.txt" file within the 'minitester' folder.
Please add them before the last line of the file (containing the 'exit\' sequence)
- New tests function properly in one-line format. At the time of writing multiline test format has not been addressed


Final considerations:
- In cases where results involve stderr messages, preference was given to expect's messaging system over bash's.
This was done, both due to expect's constraints, and to allow results to match up in diff statements whenever standard errors are involved.
This also means that you won't be able to compare your shell's own messaging system against the original bash when running 'minitester'.
- A validation was added to avoid failing scores in tests containing the character ';'.
This was done to avoid mismatching results, as the project guides state that this character is not to be interpreted by your minishell.
If needed, the same can be removed by deleting the 'elif' condition and corresponding statements in 'veridict.sh'.

Thanks!
cat: res27: input file is output file
[H[2J[3Jbonjour
cat: test_list: Is a directory
"  "
""
"" | ""
''
(|)
..
|
$? * $?
$LESS$VAR
$SHLVL
'$TERM'
$TERM
$test
$test | $test
$test && echo $?
$test || echo $?
>a ls >b >>c >d
>a ls <machin >>c >d
/bin/echo bonjour
/bin/ls
/bin/ls && echo $?
/bin/ls || echo $?
/bin/ls este_ficheir_nao_existe && echo $?
/bin/ls este_ficheir_nao_existe || echo $?
/bin/pwd
>|cat
cat bla
(cat echo 5)
cat echo 5
cat file.txt | grep 'error' | wc -l
cat file.txt | tr -s ' ' '\n' | sort | uniq -c | sort -nr
cat file.txt | tr -s ' ' '\n' | sort | uniq -c | sort -nr | awk '{print $2 $1}'
cat *.h | grep struct > structs_file && echo "_STRUCT LIST:" >> structs_file && sort structs_file > sorted_structs && cat sorted_structs && rm *structs*
(cat lonely)
cat lonely
cat lonely $test*
cat lonely | clear | echo 5
cat lonely || echo $?
((cat lonely || echo $? > erro) | ls) && cat erro
cat lonely && echo $? | > test
cat lonely | (echo 5)
cat lonely|(ls)
cat lonely | ls && cat lonely | ls
cat magic
cat << magic > magic
cat Makefile | grep pr | head -n 5 | cd file_not_exit
cat Makefile | grep pr | head -n 5 | hello
cat *test
cat < test
cat test
cat test**
cat test$*
"cd .."
'cd ..'
cd ""
cd ../../../../../..
CD .
CD ..
cd $HOME/Bureau
cd $vari
cd $vari ""
cd /home/..
cd /home/dir
cd /home/user42/
cd ./path_not_found
cd ~ && pwd
cd . && pwd && cd .. && pwd && pwd && cd /bin/ls && pwd
cd random_cmd && echo $?
cd random_cmd ; echo $?
cd too many arguments
(clear)
clear | $test
clear < results
clear > results
diff test test2
echo
echo $*
echo $>?
echo $? % $?
echo $? + $?
echo $OLDPWD && cd $OLDPWD && echo $OLDPWD && cd $OLDPWD && echo $OLDPWD
echo $PATH | wc -l | grep 1 | echo $? | grep 0
echo $PWD >> test1 >> test2 > test1
(echo $test) && echo $? > test3
echo "$tests" "Makefile"
echo "$tests""Makefile"
echo "$tests"Makefile
echo $USER
echo $USER$var\$USER$USER\$USERtest$USER
echo '$USER' echo $USER
echo $var bonjour
echo "12\""
echo 2 > out1 >> out2
echo 2 >> out1 > out2
(echo 5)
echo 5
(echo 5 cat)
echo 5 cat
echo 5 | (cat)
echo\ a
echo "'abc'"
echo '"abc"'
echo "agora 'mais' fdd"
echo a"hey | ls
echo a"hey" | ls
echo a"hey"|ls
echo a"hey|ls
echo "bip | bip ><"
echo "" bonjour
echo bonjour > $test
echo bonjour && ls
echo bonjour \; ls
echo bonjour > "test 1"
echo "cat lol.c | cat > lol.c"
echo "''" | grep ""
echo "Hello && World!"
echo "Hello | World!"
echo "Hello || World!"
echo "Hello && world!" > output.txt && cat output.txt && echo "Hello world!" >> output.txt && cat output.txt
echo "Hello | world!" > output.txt && cat output.txt && echo "Hello world!" >> output.txt && cat output.txt
echo "Hello || world!" > output.txt && cat output.txt && echo "Hello world!" >> output.txt && cat output.txt
echo "hey" | ls
echo "hey" | ls
echo "hey"|ls
echo "hey|ls
echo -n
echo -n ""
(((echo -n 4) && echo 2))
((echo -n 4) && echo 2)
echo -nnm teste
echo -nnm "" | wc -l | grep 1
echo -n -nn -nnm teste
echo -nnnn teste
echo -nnn "" | wc -l | grep 0 | wc -l
echo -n -nteste
echo -n 'serÃ¡"que vai dar'parsing"
echo -n "" | wc -l | grep 0 | wc -l
echo "" -n | wc -l | grep 1
echo "pedro pinto"
echo "\s" && echo "\\s"
echo "\s" ; echo "\\s"
echo test|
echo test|>
echo test|>cat
echo test|cat
echo test|cat>
echo teste
echo test > file test1
echo "This is a error \n test file. line1\nline2 error \nline3error" > file.txt
echo "" | wc -l | grep 1
env
env ""
env $vari
env > test
env > test2
exit 1 exit
exit 300 || echo $?
exit | echo $? > test
exit exit 1
exit << magic
export
export ""
export ($test)
(export $test) && export
(export $test) && export > test1 && unset test && export > test2 && diff test1 test2
export $test && export > test1 && unset test && export > test2 && diff test1 test2
export $var
export $var=test
export $var=test && export $var
export $var=test ; export $var
export 3A && echo $? && unset 3A && echo $?
export 3A && echo $? || unset 3A && echo $?
export 3A || echo $? && unset 3A || echo $?
export 3A || echo $? || unset 3A || echo $?
export "" . : , ! \\ + = - _ _a
export  a127  a=
export  a127  a= " "
export A2=34 A2=42 && export && export | wc -l && env | wc -l && echo $A2 && unset A2
export A2=34 && export && export | wc -l && env | wc -l && echo $A2 && unset A2
export A2=42 && export && export | wc -l && env | wc -l && echo $A2 && unset A2
export a=a b=b c=c d=d e=e && echo "$a "$b" $c $d" "$e" && unset a b c d e
export ...cookie? $OLDPWD
export cookie OLDPWD
(export (echo -n $test))
export env
export | grep cookie > test
export | grep OLDPWD >> test
export HOME= && cd
export HOME= ; cd
export loop='bonjour$loop' && echo $loop
export loop='bonjour$loop' ; echo $loop
export Nao_Existe && echo $?
export Nao_Existe || echo $?
export test=123\" && echo $test
export test=123\" ; echo $test
export test=123\\ && echo $test
export test=123\\ ; echo $test
export test=123\' && echo $test && echo $test
export test=123\' ; echo $test ; echo $test
export test1="export test2=test3" && $test1 && echo $test2
export "" test=a
export test=a && echo $test
export test=a ; echo $test
export test="env | grep OLDPWD" && $test
export test="exit" && ($test) && echo $?
(export test="exit 1123a" && ($test)) || echo $?
(export test="exit 1224" && ($test)) || echo $?
(export test="exit 1224a" && ($test)) || echo $?
export test="  foo    bar  " && echo $test
export test="  foo    bar  " ; echo $test
export test=" foo   bar " && echo """$test"""
export test=" foo   bar " && echo ""$test""
export test=" foo   bar " && echo "$test"
export test=" foo   bar " ; echo """$test"""
export test=" foo   bar " ; echo ""$test""
export test=" foo   bar " ; echo "$test"
export test="  foo    bar  " && echo "ab"$test
export test="  foo    bar  " && echo ab$test
export test="  foo    bar  " ; echo "ab"$test
export test="  foo    bar  " ; echo ab$test
export test=" foo   bar " && echo ab"$test" | cat -e
export test=" foo   bar " ; echo ab"$test" | cat -e
export "test=ici"=coucou && echo $test
export "test=ici"=coucou ; echo $test
export ""  && unset ""
export var=a && export $var=test && echo $var $a
export var=a ; export $var=test ; echo $var $a
export var=at && c$var Makefile
export var=at ; c$var Makefile
export var="cat Makefile | grep >" && echo $var
export var="cat Makefile | grep >" ; echo $var
export var entÃ£o export var = teste
export var= s\ -la && l$var
export var= s\ -la ; l$var
export VAR="This is a test variable." && echo $VAR && unset VAR && echo $VAR && cat output.txt
export var="  truc"&& echo $var
export var="  truc"; echo $var
export var="truc  "&& echo $var | cat -e
export var="truc  "; echo $var | cat -e
>file
file_name
./file_that_is_not_an_executable
find . -name "*.txt" -exec cat {} + | wc -l
find /path/to/directory -type f -size +100M -printf '%f %s\n' | exit
find . -type f | wc -l
ls *
ls bonjour && echo $?
ls bonjour ; echo $?
(ls)|cat
(ls|)cat
ls(|)cat
ls | exit
ls -l < input.txt > output.txt && cat output.txt
ls | sort
'ls | 'wc' '|' >> 1.txt'
'ls | wc | >> 1.txt'
ls | wc | >> 1.txt
<< magic wc
./minishell < exit 122 > lixo && echo $?
./minishell < exit 122 > lixo || echo $?
./minishell < exit 122 > lixo && echo $?
./minishell < exit 122 > || echo $?
./minishell < exit 50 > && echo $?
./minishell < exit 50 > || echo $?
./minishell < exit 50 > && echo $?
./minishell < exit 50 > || echo $?
./minishell < exit && > echo $?
./minishell < exit || > echo $?
./minishell < exit && > echo $?
./minishell < exit || > echo $?
./minishell	< ./minishell < exit 300 && echo $?
not_cmd
not_cmd bonjour > salut
< potato cd $PWD
ps aux --sort=-%mem | head -n 10
pwd && cd . && (pwd && cd .. && pwd) && pwd && cd $OLDPWD && pwd && cd $PWD
(pwd && cd .. && pwd) && pwd && cd .
/sbin/env
/snap/bin/no_command
sort < output.txt && cat output.txt
sort -r << test > potato
sort t* > test
TERM
test|
>test|cat
test|cat
test|cat>
> test | echo blabla
> test | echo blabla; rm test
(unset $HOME) && env
unset "" . : , ! \\ + = - _ _a
unset a*
unset  ...cookie? ""
unset HOME
unset / -n
unset PATH && env && echo $? && export PATH="/usr/local/bin:/usr/bin:/bin:/usr/local/sbin:/usr/sbin:/sbin" && env && echo $?
unset PATH ; ls
unset PWD
unset TERM && env && export TERM=new_term_42
unset "" test
unset test && $test
unset test && (export test="" && export > test1) && export $test > test2 && diff test1 test2
unset test && export test="" && export > test1 && export $test > test2 && diff test1 test2
unset var
/usr/local/bin/pwd
/usr/share/echo -n pinto
"  "
""
"" | ""
''
(|)
..
|
$? * $?
$LESS$VAR
$SHLVL
'$TERM'
$TERM
$test
$test | $test
>a ls >b >>c >d
>a ls <machin >>c >d
/bin/echo bonjour
/bin/ls
/bin/pwd
>|cat
cat bla
cat echo 5
cat file.txt | grep 'error' | wc -l
cat file.txt | tr -s ' ' '\n' | sort | uniq -c | sort -nr
cat file.txt | tr -s ' ' '\n' | sort | uniq -c | sort -nr | awk '{print $2 $1}'
cat lonely
cat lonely $test*
cat lonely | clear | echo 5
cat magic
cat << magic > magic
cat Makefile | grep pr | head -n 5 | cd file_not_exit
cat Makefile | grep pr | head -n 5 | hello
cat < test
cat test
"cd .."
'cd ..'
cd ""
cd ../../../../../..
CD .
CD ..
cd $HOME/Bureau
cd $vari
cd $vari ""
cd /home/..
cd /home/dir
cd /home/user42/
cd ./path_not_found
cd too many arguments
clear | $test
clear < results
clear > results
diff test test2
echo
echo $*
echo $>?
echo $? % $?
echo $? + $?
echo $PATH | wc -l | grep 1 | echo $? | grep 0
echo $PWD >> test1 >> test2 > test1
echo "$tests" "Makefile"
echo "$tests""Makefile"
echo "$tests"Makefile
echo $USER
echo $USER$var\$USER$USER\$USERtest$USER
echo '$USER' echo $USER
echo $var bonjour
echo "12\""
echo 2 > out1 >> out2
echo 2 >> out1 > out2
echo 5
echo 5 cat
echo\ a
echo "'abc'"
echo '"abc"'
echo "agora 'mais' fdd"
echo a"hey | ls
echo a"hey" | ls
echo a"hey"|ls
echo a"hey|ls
echo "bip | bip ><"
echo "" bonjour
echo bonjour > $test
echo bonjour > "test 1"
echo "cat lol.c | cat > lol.c"
echo "''" | grep ""
echo "Hello | World!"
echo "hey" | ls
echo "hey"|ls
echo "hey|ls
echo -n
echo -n ""
echo -nnm teste
echo -nnm "" | wc -l | grep 1
echo -n -nn -nnm teste
echo -nnnn teste
echo -nnn "" | wc -l | grep 0 | wc -l
echo -n -nteste
echo -n 'serÃ¡"que vai dar'parsing"
echo -n "" | wc -l | grep 0 | wc -l
echo "" -n | wc -l | grep 1
echo "pedro pinto"
echo test|
echo test|>
echo test|>cat
echo test|cat
echo test|cat>
echo teste
echo test > file test1
echo "This is a error \n test file. line1\nline2 error \nline3error" > file.txt
echo "" | wc -l | grep 1
env
env ""
env $vari
env > test
env > test2
exit 1 exit
exit | echo $? > test
exit exit 1
exit << magic
export
export ""
export $var
export $var=test
export "" . : , ! \\ + = - _ _a
export  a127  a=
export  a127  a= " "
export a=a b=b c=c d=d e=e
echo "$a "$b" $c $d" "$e"
unset a b c d e
export ...cookie? $OLDPWD
export cookie OLDPWD
export env
export | grep cookie > test
export | grep OLDPWD >> test
export "" test=a
export ""  && unset ""
export var=a && export $var=test && echo $var $a
export var entÃ£o export var = teste
>file
file_name
./file_that_is_not_an_executable
find . -name "*.txt" -exec cat {} + | wc -l
find /path/to/directory -type f -size +100M -printf '%f %s\n' | exit
find . -type f | wc -l
ls *
ls | exit
ls | sort
'ls | 'wc' '|' >> 1.txt'
'ls | wc | >> 1.txt'
ls | wc | >> 1.txt
<< magic wc
not_cmd
not_cmd bonjour > salut
< potato cd $PWD
ps aux --sort=-%mem | head -n 10
/sbin/env
/snap/bin/no_command
sort -r << test > potato
sort t* > test
TERM
test|
>test|cat
test|cat
test|cat>
> test | echo blabla
unset "" . : , ! \\ + = - _ _a
unset a*
unset  ...cookie? ""
unset HOME
unset / -n
unset PWD
unset "" test
unset var
/usr/local/bin/pwd
/usr/share/echo -n pinto
#!/usr/bin/env bash

# ANSI color escape sequences
RED='\033[1;31m'
GREEN='\033[1;32m'
WHITE='\033[1;37m'
BLUE='\033[1;34m'
CYAN='\033[1;36m'
UNDERLINE='\033[4m'
RESET='\033[0m'

#Gathering needed variables
filename='res.txt'
directory='out_minishell'
prefix1="[?2004h"
prefix2="[?2004l"

# Reading results
readfile()
{
read="$1"

while read line; do
echo $line
done < ${read}
}

# Comparing results
veridict()
{
count=0
n=1
while read line; do
if [[ "${#line}" > 0 ]]; then
local res="res"
res+="$n"
if diff -q out_bash/${res} ${directory}/${res} > /dev/null 2>&1; then
echo -ne "Test ${n}: ${GREEN} [OK]${RESET}"
echo ""
count=$((count+1))
elif [[ "${line}" = *";"* ]]; then
echo -ne "Test ${n}: ${GREEN} [OK]${RESET}"
echo ""
else
echo -e "Test ${n}: ${RED} [KO]${RESET}"
echo ""
if [[ $(cat "test_list/test${n}") != *"env"* && $(cat "test_list/test${n}") != *"export"* && $line != *"*"* ]]; then
echo "_____________________________"
echo -e "${GREEN}Test ${n}:${RESET}"
echo $(cat test_list/test${n})
echo -e "${GREEN}Bash: ${RESET}"
readfile "out_bash/res${n}"
echo -e "${GREEN}Mini: ${RESET}"
readfile "out_minishell/res${n}"
echo "_____________________________"
echo ""
fi
fi
echo "${count}/${n}"
n=$((n+1))
fi
done < tests.txt
}

# Getting the results!
chmod +rwx $directory;
chmod +rwx out_bash;
veridict;
exit;
